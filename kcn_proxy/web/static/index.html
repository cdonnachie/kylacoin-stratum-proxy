<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KCN-LCN Solo Mining Dashboard</title>
    <link rel="stylesheet" href="/static/dashboard.css" />
    <link rel="icon" type="image/png" href="/static/kylacoin-logo.png" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>
        <img
          src="/static/kylacoin-logo.png"
          alt="KCN"
          class="logo"
          onerror="this.style.display='none'"
        />
        KCN-LCN Solo Mining Dashboard
        <img
          src="/static/lyncoin-logo.png"
          alt="LCN"
          class="logo"
          onerror="this.style.display='none'"
        />
      </h1>

      <div class="stats-grid">
        <div
          class="stat-card"
          title="Current aggregated rolling hashrate (5m window). Toggle shows Instant (raw window) vs EMA (smoothed)."
        >
          <h3
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              gap: 8px;
            "
          >
            <span>Total Hashrate</span>
            <label
              style="
                font-size: 0.55em;
                display: flex;
                align-items: center;
                gap: 4px;
                cursor: pointer;
                opacity: 0.8;
              "
            >
              <input
                type="checkbox"
                id="mode-toggle-hashrate"
                style="accent-color: #05a532; cursor: pointer"
              />
              <span
                title="Toggle between EMA (smoothed) and Instant (raw) aggregate hashrate"
                >Instant</span
              >
            </label>
          </h3>
          <div style="display: flex; align-items: baseline; gap: 10px">
            <div class="value" id="total-hashrate">0.00</div>
            <div class="unit" id="total-hashrate-unit">H/s</div>
            <div
              id="total-hashrate-conf"
              style="
                font-size: 0.55em;
                letter-spacing: 0.5px;
                padding: 4px 8px;
                border-radius: 16px;
                background: rgba(255, 255, 255, 0.18);
                display: none;
              "
            >
              ±100%
            </div>
          </div>
          <div class="subtext" id="hashrate-subtext">
            Waiting for first share…
          </div>
        </div>

        <div class="stat-card">
          <h3>Active Miners</h3>
          <div class="value" id="miner-count">0</div>
          <div class="unit">Connected</div>
        </div>

        <div
          class="stat-card kcn-blocks-card"
          title="Blocks found in the last 24h and all-time total (accepted only)"
        >
          <h3>
            <img
              src="/static/kylacoin-logo.png"
              alt="KCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            KCN Blocks
          </h3>
          <div class="value" id="kcn-blocks">0</div>
          <div class="unit">24h</div>
          <div class="subtext" id="kcn-blocks-alltime">All time: 0</div>
        </div>

        <div
          class="stat-card lcn-blocks-card"
          title="Blocks found in the last 24h and all-time total (accepted only)"
        >
          <h3>
            <img
              src="/static/lyncoin-logo.png"
              alt="LCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            LCN Blocks
          </h3>
          <div class="value" id="lcn-blocks">0</div>
          <div class="unit">24h</div>
          <div class="subtext" id="lcn-blocks-alltime">All time: 0</div>
        </div>

        <div
          class="stat-card"
          title="Accepted vs total submitted shares over last 24h"
        >
          <h3>Acceptance Rate</h3>
          <div class="value" id="acceptance-rate">—</div>
          <div class="unit">%</div>
        </div>

        <div
          class="stat-card kcn-network-card"
          title="Current KCN blockchain height and network difficulty"
        >
          <h3>
            <img
              src="/static/kylacoin-logo.png"
              alt="KCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            KCN Network
          </h3>
          <div class="value" id="kcn-height" style="font-size: 1.8em">—</div>
          <div class="unit">Block Height</div>
          <div class="subtext" style="margin-top: 8px">
            <span style="opacity: 0.7">Difficulty:</span>
            <span id="kcn-difficulty" style="font-weight: 600">—</span>
          </div>
        </div>

        <div
          class="stat-card lcn-network-card"
          title="Current LCN blockchain height and network difficulty"
        >
          <h3>
            <img
              src="/static/lyncoin-logo.png"
              alt="LCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            LCN Network
          </h3>
          <div class="value" id="lcn-height" style="font-size: 1.8em">—</div>
          <div class="unit">Block Height</div>
          <div class="subtext" style="margin-top: 8px">
            <span style="opacity: 0.7">Difficulty:</span>
            <span id="lcn-difficulty" style="font-weight: 600">—</span>
          </div>
        </div>

        <div class="stat-card">
          <h3>Total Shares</h3>
          <div class="value" id="total-shares">0</div>
          <div class="unit">24h</div>
        </div>
        <div
          class="stat-card"
          title="Shares submitted (accepted + rejected) since the last found block on either chain"
        >
          <h3>Shares Since Block</h3>
          <div class="value" id="shares-since-block">—</div>
          <div class="unit" id="shares-since-block-age">—</div>
        </div>
        <div
          class="stat-card"
          title="Estimated time to find a block based on current EMA hashrate and network difficulty (statistical average)"
        >
          <h3>Time To Find</h3>
          <div
            style="
              display: flex;
              flex-direction: column;
              gap: 8px;
              margin-top: 8px;
            "
          >
            <div style="display: flex; align-items: baseline; gap: 8px">
              <img
                src="/static/kylacoin-logo.png"
                alt="KCN"
                class="chain-logo"
                style="width: 16px; height: 16px; vertical-align: middle"
                onerror="this.style.display='none'"
              />
              <span style="font-size: 0.7em; opacity: 0.7; min-width: 35px"
                >KCN:</span
              >
              <span id="ttf-kcn" class="value" style="font-size: 1.4em">—</span>
            </div>
            <div style="display: flex; align-items: baseline; gap: 8px">
              <img
                src="/static/lyncoin-logo.png"
                alt="LCN"
                class="chain-logo"
                style="width: 16px; height: 16px; vertical-align: middle"
                onerror="this.style.display='none'"
              />
              <span style="font-size: 0.7em; opacity: 0.7; min-width: 35px"
                >LCN:</span
              >
              <span id="ttf-lcn" class="value" style="font-size: 1.4em">—</span>
            </div>
          </div>
          <div class="subtext" style="margin-top: 8px">Statistical average</div>
        </div>
      </div>

      <div class="toolbar">
        <label
          class="worker-toggle"
          style="
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8em;
            letter-spacing: 0.5px;
            opacity: 0.85;
            cursor: pointer;
          "
        >
          <input
            type="checkbox"
            id="worker-mode-toggle"
            checked
            style="
              accent-color: #05a532;
              width: 16px;
              height: 16px;
              cursor: pointer;
            "
          />
          <span>Compact worker names</span>
        </label>
        <span style="font-size: 0.7em; opacity: 0.55"
          >(Toggle to show full wallet.worker identifiers)</span
        >
        <div class="maintenance-group" aria-label="Maintenance actions">
          <button
            id="flush-hashrate"
            class="toolbar-btn"
            title="Clear rolling window + EMA so fresh hashrate accumulates"
          >
            Flush Hashrate Window
          </button>
          <div
            id="fix-lcn-group"
            style="display: none; align-items: center; gap: 10px"
          >
            <button
              id="fix-lcn-hashes"
              class="toolbar-btn"
              title="Correct historical LCN block hashes using node RPC"
            >
              Fix LCN Hashes
            </button>
            <label class="mini-option" title="Run without writing DB changes">
              <input type="checkbox" id="fix-lcn-dryrun" checked />Dry‑run
            </label>
            <label
              class="mini-option"
              for="fix-lcn-limit"
              title="Limit number of historical rows to process (blank = all)"
            >
              Limit
              <input
                type="number"
                id="fix-lcn-limit"
                min="1"
                placeholder="All"
              />
            </label>
            <span
              id="fix-lcn-status"
              class="maintenance-status"
              aria-live="polite"
            ></span>
          </div>
        </div>
      </div>

      <div class="explorers" aria-label="Explorer quick links">
        <a
          href="https://kcnxp.com/"
          target="_blank"
          rel="noopener"
          title="KCN Explorer Home"
          ><span class="chain-tag">KCN</span>Explorer</a
        >
        <a
          class="lcn"
          href="https://lcnxp.com/"
          target="_blank"
          rel="noopener"
          title="LCN Explorer Home"
          ><span class="chain-tag">LCN</span>Explorer</a
        >
      </div>

      <!-- Daemon Status Section -->
      <div class="section">
        <h2
          style="cursor: pointer; user-select: none"
          onclick="toggleDaemonStatus()"
        >
          <span id="daemon-toggle-icon">▼</span> Blockchain Daemon Status
        </h2>
        <div id="daemon-status-content">
          <div class="stats-grid" style="margin-top: 16px">
            <!-- Kylacoin Daemon -->
            <div class="stat-card kcn-network-card">
              <h3>
                <img
                  src="/static/kylacoin-logo.png"
                  alt="KCN"
                  class="chain-logo"
                  onerror="this.style.display='none'"
                />
                Kylacoin Node
              </h3>
              <div
                style="margin-top: 12px; font-size: 0.85em; line-height: 1.6"
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Status:</span>
                  <span id="kcn-daemon-status" style="font-weight: 600">—</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Sync:</span>
                  <span id="kcn-sync-progress" style="font-weight: 600">—</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Connections:</span>
                  <span id="kcn-connections" style="font-weight: 600">—</span>
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span style="opacity: 0.7">Version:</span>
                  <span id="kcn-version" style="font-weight: 600">—</span>
                </div>
              </div>
            </div>

            <!-- Lyncoin Daemon -->
            <div class="stat-card lcn-network-card">
              <h3>
                <img
                  src="/static/lyncoin-logo.png"
                  alt="LCN"
                  class="chain-logo"
                  onerror="this.style.display='none'"
                />
                Lyncoin Node
              </h3>
              <div
                style="margin-top: 12px; font-size: 0.85em; line-height: 1.6"
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Status:</span>
                  <span id="lcn-daemon-status" style="font-weight: 600">—</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Sync:</span>
                  <span id="lcn-sync-progress" style="font-weight: 600">—</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Connections:</span>
                  <span id="lcn-connections" style="font-weight: 600">—</span>
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span style="opacity: 0.7">Version:</span>
                  <span id="lcn-version" style="font-weight: 600">—</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>
          <span class="live-indicator"></span>Active Miners
          <span
            id="vardiff-badge"
            class="badge"
            style="
              display: none;
              margin-left: 12px;
              font-size: 0.6em;
              padding: 4px 10px;
              background: #057c32;
              color: #fff;
              vertical-align: middle;
            "
            title="Variable difficulty is enabled - difficulty adjusts per miner to target 15s share intervals"
            >VarDiff: Enabled</span
          >
        </h2>
        <div class="table-wrapper">
          <table id="miners-table" aria-label="Active Miners">
            <thead>
              <tr>
                <th>Worker</th>
                <th>Software</th>
                <th class="col-num">Difficulty</th>
                <th class="col-num">Hashrate</th>
                <th class="col-num">Share Intvl</th>
                <th class="col-num">Uptime</th>
              </tr>
            </thead>
            <tbody id="miners-body">
              <tr>
                <td colspan="6" class="no-data">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div
          id="miners-pagination"
          class="pagination-controls"
          style="margin-top: 12px"
        >
          <button
            id="miners-prev-btn"
            class="pagination-btn"
            onclick="minersPaginationState.page = Math.max(1, minersPaginationState.page - 1); saveMinersPaginationState(); updateMiners()"
          >
            ← Previous
          </button>
          <span id="miners-page-info" style="margin: 0 12px">Page 1 of 1</span>
          <button
            id="miners-next-btn"
            class="pagination-btn"
            onclick="minersPaginationState.page += 1; saveMinersPaginationState(); updateMiners()"
          >
            Next →
          </button>
        </div>
      </div>

      <div class="section">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="lucide lucide-pickaxe-icon lucide-pickaxe"
          >
            <path d="m14 13-8.381 8.38a1 1 0 0 1-3.001-3L11 9.999" />
            <path
              d="M15.973 4.027A13 13 0 0 0 5.902 2.373c-1.398.342-1.092 2.158.277 2.601a19.9 19.9 0 0 1 5.822 3.024"
            />
            <path
              d="M16.001 11.999a19.9 19.9 0 0 1 3.024 5.824c.444 1.369 2.26 1.676 2.603.278A13 13 0 0 0 20 8.069"
            />
            <path
              d="M18.352 3.352a1.205 1.205 0 0 0-1.704 0l-5.296 5.296a1.205 1.205 0 0 0 0 1.704l2.296 2.296a1.205 1.205 0 0 0 1.704 0l5.296-5.296a1.205 1.205 0 0 0 0-1.704z"
            />
          </svg>
          Recently Seen Miners
        </h2>
        <div style="margin-bottom: 12px">
          <label for="disconnected-miners-hours">Time Range:</label>
          <select
            id="disconnected-miners-hours"
            onchange="updateDisconnectedMiners()"
            style="margin-left: 8px; padding: 4px 8px"
          >
            <option value="24">Last 24 hours</option>
            <option value="168">Last 7 days</option>
            <option value="720">Last 30 days</option>
          </select>
        </div>
        <div class="table-wrapper">
          <table aria-label="Recently Disconnected Miners">
            <thead>
              <tr>
                <th>Worker</th>
                <th>Software</th>
                <th>Time Ago</th>
                <th>Last Seen</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="disconnected-miners-body">
              <tr>
                <td colspan="5" class="no-data">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="section">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="lucide lucide-blocks-icon lucide-blocks"
          >
            <path
              d="M10 22V7a1 1 0 0 0-1-1H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5a1 1 0 0 0-1-1H2"
            />
            <rect x="14" y="2" width="8" height="8" rx="1" />
          </svg>
          Recent Blocks
        </h2>
        <div
          id="blocks-container"
          class="dual-blocks"
          style="
            display: grid;
            gap: 24px;
            grid-template-columns: repeat(auto-fit, minmax(480px, 1fr));
          "
        >
          <div class="subsection kcn-blocks-card">
            <h3
              style="
                margin: 0 0 10px 0;
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 1em;
              "
            >
              <span class="badge badge-kcn"
                ><img
                  src="/static/kylacoin-logo.png"
                  alt=""
                  class="chain-logo"
                  onerror="this.style.display='none'"
                />KCN</span
              >
              <span style="opacity: 0.75; font-weight: 500">Blocks</span>
            </h3>
            <div class="table-wrapper">
              <table id="kcn-blocks-table" aria-label="Recent KCN Blocks">
                <thead>
                  <tr>
                    <th class="col-num">Height</th>
                    <th>Block Hash</th>
                    <th>Worker</th>
                    <th>Status</th>
                    <th class="col-num">Time</th>
                  </tr>
                </thead>
                <tbody id="kcn-blocks-body">
                  <tr>
                    <td colspan="5" class="no-data">Loading...</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div
              id="kcn-pagination"
              class="pagination-controls"
              style="
                display: none;
                margin-top: 12px;
                text-align: center;
                font-size: 0.85em;
              "
            >
              <button
                class="pagination-btn"
                onclick="prevBlocksPage('kcn')"
                title="Previous page"
              >
                ← Prev
              </button>
              <span id="kcn-page-info" style="margin: 0 12px; opacity: 0.7"
                >Page 1</span
              >
              <button
                class="pagination-btn"
                onclick="nextBlocksPage('kcn')"
                title="Next page"
              >
                Next →
              </button>
            </div>
          </div>
          <div class="subsection lcn-blocks-card">
            <h3
              style="
                margin: 0 0 10px 0;
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 1em;
              "
            >
              <span class="badge badge-lcn"
                ><img
                  src="/static/lyncoin-logo.png"
                  alt=""
                  class="chain-logo"
                  onerror="this.style.display='none'"
                />LCN</span
              >
              <span style="opacity: 0.75; font-weight: 500">Blocks</span>
            </h3>
            <div class="table-wrapper">
              <table id="lcn-blocks-table" aria-label="Recent LCN Blocks">
                <thead>
                  <tr>
                    <th class="col-num">Height</th>
                    <th>Block Hash</th>
                    <th>Worker</th>
                    <th>Status</th>
                    <th class="col-num">Time</th>
                  </tr>
                </thead>
                <tbody id="lcn-blocks-body">
                  <tr>
                    <td colspan="5" class="no-data">Loading...</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div
              id="lcn-pagination"
              class="pagination-controls"
              style="
                display: none;
                margin-top: 12px;
                text-align: center;
                font-size: 0.85em;
              "
            >
              <button
                class="pagination-btn"
                onclick="prevBlocksPage('lcn')"
                title="Previous page"
              >
                ← Prev
              </button>
              <span id="lcn-page-info" style="margin: 0 12px; opacity: 0.7"
                >Page 1</span
              >
              <button
                class="pagination-btn"
                onclick="nextBlocksPage('lcn')"
                title="Next page"
              >
                Next →
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="lucide lucide-chart-line-icon lucide-chart-line"
          >
            <path d="M3 3v16a2 2 0 0 0 2 2h16" />
            <path d="m19 9-5 5-4-4-3 3" />
          </svg>
          Network Difficulty Trend
        </h2>
        <div style="position: relative; height: 300px; margin-bottom: 20px">
          <canvas id="difficulty-chart"></canvas>
        </div>
        <div
          style="
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          "
        >
          <button
            class="toolbar-btn"
            onclick="updateDifficultyChart(24)"
            title="Last 24 hours"
          >
            24h
          </button>
          <button
            class="toolbar-btn"
            onclick="updateDifficultyChart(168)"
            title="Last 7 days"
          >
            7d
          </button>
          <button
            class="toolbar-btn"
            onclick="updateDifficultyChart(720)"
            title="Last 30 days"
          >
            30d
          </button>
        </div>
      </div>

      <div class="section">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            style="
              display: inline-block;
              vertical-align: middle;
              margin-right: 8px;
            "
          >
            <polyline points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" />
          </svg>
          Hashrate History Graph
        </h2>
        <div style="position: relative; height: 300px; margin-bottom: 20px">
          <canvas id="hashrate-chart"></canvas>
        </div>
        <div
          style="
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          "
        >
          <button
            class="toolbar-btn"
            onclick="updateHashrateChart(24)"
            title="Last 24 hours"
          >
            24h
          </button>
          <button
            class="toolbar-btn"
            onclick="updateHashrateChart(168)"
            title="Last 7 days"
          >
            7d
          </button>
        </div>
        <div
          style="
            margin-top: 12px;
            padding: 12px 16px;
            background: var(--card-highlight);
            border-radius: 6px;
            font-size: 0.8em;
            line-height: 1.5;
            color: var(--text-dim);
            border-left: 3px solid var(--badge-kcn);
          "
        >
          <strong style="color: var(--text)">💡 What to look for:</strong>
          <div style="margin-top: 8px">
            <ul style="margin: 0; padding: 0 0 0 20px">
              <li>
                <strong>Peaks</strong>: Good mining conditions, all miners
                connected
              </li>
              <li>
                <strong>Valleys</strong>: Connection issues, network congestion,
                or miner disconnects
              </li>
              <li>
                <strong>Trends</strong>: Rising hashrate = more miners joining;
                Falling hashrate = power/network issues
              </li>
            </ul>
          </div>
        </div>
      </div>

      <div class="section">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
        >
          <h2>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              class="lucide lucide-trophy-icon lucide-trophy"
            >
              <path
                d="M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978"
              />
              <path
                d="M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978"
              />
              <path d="M18 9h1.5a1 1 0 0 0 0-5H18" />
              <path d="M4 22h16" />
              <path d="M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z" />
              <path d="M6 9H4.5a1 1 0 0 1 0-5H6" />
            </svg>
            Best Shares
          </h2>
          <button
            id="clear-best-shares"
            class="toolbar-btn"
            title="Clear all best shares and start tracking fresh"
            style="margin: 0; font-size: 0.9em"
          >
            Clear
          </button>
        </div>
        <div class="table-wrapper">
          <table id="best-shares-table" aria-label="Best Shares">
            <thead>
              <tr>
                <th class="col-num">Rank</th>
                <th>Difficulty</th>
                <th>KCN Ratio</th>
                <th>LCN Ratio</th>
                <th>Worker</th>
                <th class="col-num">Time</th>
              </tr>
            </thead>
            <tbody id="best-shares-body">
              <tr>
                <td colspan="7" class="no-data">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div
          style="
            margin-top: 12px;
            padding: 12px 16px;
            background: var(--card-highlight);
            border-radius: 6px;
            font-size: 0.8em;
            line-height: 1.5;
            color: var(--text-dim);
            border-left: 3px solid var(--badge-kcn);
          "
        >
          <strong style="color: var(--text)">💡 Ratio Explanation:</strong>
          <div style="margin-top: 8px">
            The ratio shows how your share difficulty compares to each chain's
            network target:
            <ul style="margin: 8px 0 8px 20px; padding: 0">
              <li>
                <strong>Ratio < 1.0</strong> (e.g., "0.28x", "0.42x"): Share is
                below network target—accepted as a regular share
              </li>
              <li>
                <strong>Ratio ≥ 1.0</strong> (e.g., "1.0x", "2.97x"): Share
                meets or exceeds network difficulty—submitted as a block!
              </li>
              <li>
                <strong>"1 in X" format</strong> (e.g., "1 in 300", "1 in 107"):
                Very small ratio shares shown as inverse odds. This helps
                understand rarity of very low difficulty shares.
              </li>
            </ul>
            In merged mining, both chains receive your hash submissions
            simultaneously. Any share that reaches or exceeds a chain's target
            difficulty is submitted as a block to that chain. The higher the
            ratio above 1.0, the better the share quality.
          </div>
        </div>
      </div>

      <div class="section">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            style="
              display: inline-block;
              vertical-align: middle;
              margin-right: 8px;
            "
          >
            <circle cx="8" cy="8" r="6" />
            <path d="M18.09 10.37A6 6 0 1 1 10.34 18" />
            <path d="M7 6h1v4" />
            <path d="m16.71 13.88.7.71-2.82 2.82" />
          </svg>
          Payout Addresses
        </h2>
        <div class="table-wrapper">
          <table aria-label="Payout Addresses">
            <thead>
              <tr>
                <th>Chain</th>
                <th>Address</th>
                <th>Source</th>
              </tr>
            </thead>
            <tbody id="payouts-body">
              <tr>
                <td colspan="3" class="no-data">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div
        class="status-bar"
        id="status-bar"
        style="
          margin-top: 30px;
          padding: 16px 24px;
          background: rgba(255, 255, 255, 0.05);
          border-radius: 8px;
          display: flex;
          flex-wrap: wrap;
          gap: 24px;
          align-items: center;
          font-size: 0.85em;
          border: 1px solid rgba(255, 255, 255, 0.1);
        "
      >
        <div style="font-weight: 600; opacity: 0.7; margin-right: 8px">
          System Configuration:
        </div>
        <div id="status-vardiff" class="status-item" style="display: none">
          <span style="color: #05a532; margin-right: 4px">●</span>
          <span title="Variable difficulty is enabled">VarDiff</span>
          <span
            class="status-detail"
            style="opacity: 0.6; margin-left: 6px; font-size: 0.9em"
          ></span>
        </div>
        <div id="status-zmq" class="status-item" style="display: none">
          <span style="color: #05a532; margin-right: 4px">●</span>
          <span title="ZeroMQ block notifications enabled">ZMQ</span>
        </div>
        <div
          id="status-notifications"
          class="status-item"
          style="display: none"
        >
          <span style="color: #05a532; margin-right: 4px">●</span>
          <span>Notifications</span>
          <span
            class="status-detail"
            style="opacity: 0.6; margin-left: 6px; font-size: 0.9em"
          ></span>
        </div>
        <div id="status-database" class="status-item" style="display: none">
          <span style="color: #05a532; margin-right: 4px">●</span>
          <span title="Database logging enabled">Database</span>
        </div>
        <div id="status-stratum" class="status-item" style="display: none">
          <span style="color: #05a532; margin-right: 4px">●</span>
          <span title="Stratum server port">Port:</span>
          <span class="status-detail" style="margin-left: 4px; font-weight: 500"
            >—</span
          >
        </div>
        <div id="status-loading" style="opacity: 0.5; font-style: italic">
          Loading configuration...
        </div>
      </div>

      <div class="update-time">
        Last updated: <span id="last-update">Never</span>
      </div>
    </div>

    <script>
      // Insert floating theme toggle at runtime (ensures CSS loaded)
      (function createFloatingThemeToggle() {
        const fab = document.createElement("button");
        fab.id = "theme-toggle";
        fab.className = "theme-toggle-fab";
        fab.innerHTML =
          '<span class="icon" aria-hidden="true">🌙</span><span class="label">Light Mode</span>';
        document.body.appendChild(fab);
      })();

      function formatHashrate(miner) {
        // Use the new hashrate_display field if available, otherwise fallback to old format
        if (miner.hashrate_display) {
          return miner.hashrate_display;
        }
        // Fallback for backward compatibility
        const mhs = miner.hashrate_mhs || 0;
        if (mhs === 0) {
          return "0.00 H/s";
        }
        if (mhs >= 1000) {
          return (mhs / 1000).toFixed(2) + " GH/s";
        }
        return mhs.toFixed(2) + " MH/s";
      }

      function formatUptime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (hours > 0) {
          return `${hours}h ${minutes}m`;
        } else if (minutes > 0) {
          return `${minutes}m ${secs}s`;
        }
        return `${secs}s`;
      }

      function formatTime(timestamp) {
        const date = new Date(timestamp * 1000);
        const now = new Date();
        const diff = Math.floor((now - date) / 1000);

        if (diff < 60) return `${diff}s ago`;
        if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
        if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
        return `${Math.floor(diff / 86400)}d ago`;
      }

      function shortenHash(hash) {
        if (!hash) return "";
        if (hash.length <= 20) return hash;
        return hash.substring(0, 10) + "..." + hash.substring(hash.length - 10);
      }

      function formatDifficulty(difficulty) {
        if (!difficulty || difficulty === 0) return "—";
        if (difficulty >= 1_000_000_000) {
          return (difficulty / 1_000_000_000).toFixed(2) + " G";
        }
        if (difficulty >= 1_000_000) {
          return (difficulty / 1_000_000).toFixed(2) + " M";
        }
        if (difficulty >= 1_000) {
          return (difficulty / 1_000).toFixed(2) + " K";
        }
        return difficulty.toFixed(8);
      }

      function formatRatio(ratio) {
        if (!ratio || ratio <= 0) return "-";

        // For very small ratios (< 0.01), show "1 in X" format
        if (ratio < 0.01) {
          const inverse = Math.round(1 / ratio);
          if (inverse >= 1000000) {
            return `1 in ${(inverse / 1000000).toFixed(1)}M`;
          } else if (inverse >= 1000) {
            return `1 in ${(inverse / 1000).toFixed(0)}K`;
          } else {
            return `1 in ${inverse}`;
          }
        }

        return `${ratio.toFixed(2)}x`;
      }

      function copyToClipboard(text, button) {
        if (!navigator.clipboard) {
          // Fallback
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          try {
            document.execCommand("copy");
          } catch (e) {}
          document.body.removeChild(ta);
        } else {
          navigator.clipboard.writeText(text).catch(() => {});
        }
        if (button) {
          button.classList.add("copied");
          const original = button.textContent;
          button.textContent = "Copied";
          setTimeout(() => {
            button.classList.remove("copied");
            button.textContent = original;
          }, 1200);
        }
      }

      // Toggle daemon status section visibility
      function toggleDaemonStatus() {
        const content = document.getElementById("daemon-status-content");
        const header = document.querySelector(
          ".section h2[onclick='toggleDaemonStatus()']"
        );
        if (!content || !header) return;

        if (content.style.display === "none") {
          content.style.display = "grid";
          header.textContent = "▼ Blockchain Daemon Status";
        } else {
          content.style.display = "none";
          header.textContent = "▶ Blockchain Daemon Status";
        }
      }

      // Update daemon status information
      async function updateDaemonStatus() {
        try {
          const response = await fetch("/api/daemon-status");
          if (!response.ok) throw new Error("Failed to fetch daemon status");

          const data = await response.json();

          // Update KCN daemon
          updateDaemonCard("kcn", data.kcn);

          // Update LCN daemon
          updateDaemonCard("lcn", data.lcn);
        } catch (error) {
          console.error("Error updating daemon status:", error);
          // Show error state
          ["kcn", "lcn"].forEach((chain) => {
            const statusEl = document.getElementById(`${chain}-daemon-status`);
            if (statusEl) statusEl.textContent = "Error";
          });
        }
      }

      // Helper function to update individual daemon card
      function updateDaemonCard(chain, info) {
        if (!info) return;

        // Update status
        const statusEl = document.getElementById(`${chain}-daemon-status`);
        if (statusEl) {
          statusEl.textContent = info.status || "—";
          // Set color based on status
          if (info.status === "Connected") {
            statusEl.style.color = "#2ecc71";
          } else if (info.status === "Timeout" || info.status === "Offline") {
            statusEl.style.color = "#ff6b6b";
          } else {
            statusEl.style.color = "#f1c40f";
          }
        }

        // Update sync progress
        const syncEl = document.getElementById(`${chain}-sync-progress`);
        if (syncEl) {
          if (info.status === "Connected") {
            syncEl.textContent = `${info.sync || "—"} (${
              info.blocks || 0
            } blocks)`;
          } else {
            syncEl.textContent = "—";
          }
        }

        // Update connections
        const connEl = document.getElementById(`${chain}-connections`);
        if (connEl) {
          connEl.textContent =
            info.connections !== undefined ? `${info.connections}` : "—";
        }

        // Update version
        const versionEl = document.getElementById(`${chain}-version`);
        if (versionEl) {
          versionEl.textContent = info.version || "—";
        }
      }

      // Show only the worker name (suffix) to reduce width; keep full in tooltip
      let workerCompactMode = true;

      function displayWorker(full) {
        if (!full) return "";
        if (!workerCompactMode) return full; // full mode
        if (full.includes(".")) {
          const parts = full.split(".");
          for (let i = parts.length - 1; i >= 0; i--) {
            if (parts[i]) return parts[i];
          }
        }
        return full;
      }

      function formatDate(date) {
        return date.toLocaleDateString() + " " + date.toLocaleTimeString();
      }

      function getTimeAgo(date) {
        const now = new Date();
        const diff = Math.floor((now - date) / 1000); // seconds

        const MINUTE = 60;
        const HOUR = 60 * MINUTE;
        const DAY = 24 * HOUR;

        if (diff < MINUTE) {
          return "just now";
        } else if (diff < HOUR) {
          const mins = Math.floor(diff / MINUTE);
          return `${mins}m ago`;
        } else if (diff < DAY) {
          const hours = Math.floor(diff / HOUR);
          return `${hours}h ago`;
        } else {
          const days = Math.floor(diff / DAY);
          return `${days}d ago`;
        }
      }

      function formatTTF(seconds) {
        if (!seconds || seconds <= 0) return "—";

        const MINUTE = 60;
        const HOUR = 60 * MINUTE;
        const DAY = 24 * HOUR;
        const WEEK = 7 * DAY;
        const MONTH = 30 * DAY; // Approximate

        if (seconds < MINUTE) {
          return `${Math.round(seconds)}s`;
        } else if (seconds < HOUR) {
          const mins = seconds / MINUTE;
          return `${mins.toFixed(1)}m`;
        } else if (seconds < DAY) {
          const hours = seconds / HOUR;
          return `${hours.toFixed(1)}h`;
        } else if (seconds < WEEK) {
          const days = seconds / DAY;
          return `${days.toFixed(1)}d`;
        } else if (seconds < MONTH) {
          const weeks = seconds / WEEK;
          return `${weeks.toFixed(1)}w`;
        } else {
          const months = seconds / MONTH;
          return `${months.toFixed(1)}mo`;
        }
      }

      // Pagination state for miners
      const minersPaginationState = {
        page: 1,
        limit: 20,
        total: 0,
        miners: [],
      };

      // Load/save miner pagination state
      function loadMinersPaginationState() {
        try {
          const saved = localStorage.getItem("minersPaginationPage");
          if (saved) {
            minersPaginationState.page = parseInt(saved) || 1;
          }
        } catch (e) {
          console.debug("Could not load miners pagination state:", e);
        }
      }

      function saveMinersPaginationState() {
        try {
          localStorage.setItem(
            "minersPaginationPage",
            minersPaginationState.page
          );
        } catch (e) {
          console.debug("Could not save miners pagination state:", e);
        }
      }

      async function updateMiners() {
        try {
          loadMinersPaginationState();
          const response = await fetch("/api/miners");
          const data = await response.json();

          // Store all miners for client-side pagination
          minersPaginationState.miners = data.miners || [];
          minersPaginationState.total = minersPaginationState.miners.length;

          // Calculate pagination
          const totalPages =
            Math.ceil(
              minersPaginationState.miners.length / minersPaginationState.limit
            ) || 1;
          if (minersPaginationState.page > totalPages) {
            minersPaginationState.page = Math.max(1, totalPages);
            saveMinersPaginationState();
          }

          const offset =
            (minersPaginationState.page - 1) * minersPaginationState.limit;
          const pageMiners = minersPaginationState.miners.slice(
            offset,
            offset + minersPaginationState.limit
          );

          // Update VarDiff badge visibility
          const vardiffBadge = document.getElementById("vardiff-badge");
          if (vardiffBadge) {
            vardiffBadge.style.display = data.vardiff_enabled
              ? "inline-block"
              : "none";
          }

          const instantMode = document.getElementById(
            "mode-toggle-hashrate"
          ).checked;
          let displayStr, relErr, sharesWin;
          if (instantMode) {
            displayStr =
              data.total_instant_display || data.total_hashrate_display;
          } else {
            displayStr = data.total_ema_display || data.total_hashrate_display;
          }
          if (displayStr) {
            const parts = displayStr.split(" ");
            document.getElementById("total-hashrate").textContent = parts[0];
            document.getElementById("total-hashrate-unit").textContent =
              parts[1] || "H/s";
          }
          relErr = data.total_rel_error_est ?? 1.0;
          sharesWin = data.total_shares_in_window ?? 0;
          const confEl = document.getElementById("total-hashrate-conf");
          if (sharesWin > 0) {
            const pct = (relErr * 100).toFixed(relErr * 100 >= 10 ? 1 : 2);
            confEl.textContent = `±${pct}%`;
            confEl.style.display = "inline-block";
            // Color scale: green (<5%), amber (<15%), red otherwise
            let bg;
            if (relErr < 0.05) bg = "#057c32";
            else if (relErr < 0.15) bg = "#a66b00";
            else bg = "#a60000";
            confEl.style.background = bg;
          } else {
            confEl.style.display = "none";
          }
          document.getElementById("hashrate-subtext").textContent = instantMode
            ? "Instant window-based aggregate hashrate"
            : "EMA-smoothed aggregate hashrate";
          document.getElementById("miner-count").textContent = data.miner_count;

          const tbody = document.getElementById("miners-body");
          if (pageMiners.length === 0) {
            tbody.innerHTML =
              '<tr><td colspan="6" class="no-data">No miners connected</td></tr>';
          } else {
            tbody.innerHTML = pageMiners
              .map((miner) => {
                const diffCell =
                  miner.assigned_difficulty != null
                    ? miner.assigned_difficulty.toFixed(10)
                    : "—";
                const hashrateTooltip = [
                  `Assigned diff: ${miner.assigned_difficulty ?? "n/a"}`,
                  `Instant: ${(miner.hashrate_instant_hs ?? 0).toFixed(2)} H/s`,
                  `EMA: ${(miner.hashrate_ema_hs ?? 0).toFixed(2)} H/s`,
                  `Shares: ${miner.shares_in_window}`,
                  `Rel Err: ±${((miner.rel_error_est || 0) * 100).toFixed(1)}%`,
                ].join("&#10;");
                let shareIntvlDisplay = "—";
                let shareIntvlTooltip = "No interval data yet";
                if (
                  miner.share_blended_interval != null &&
                  miner.share_blended_interval > 0 &&
                  miner.target_interval
                ) {
                  const blended = miner.share_blended_interval;
                  const target = miner.target_interval;
                  const pct = (blended / target) * 100;
                  const avg = miner.share_avg_interval;
                  const ema = miner.share_ema_interval;
                  shareIntvlDisplay =
                    `${blended.toFixed(1)}s` +
                    '<br/><span style="opacity:.7;font-size:.7em">' +
                    pct.toFixed(0) +
                    "%</span>";
                  shareIntvlTooltip = [
                    `Target: ${target.toFixed(1)}s`,
                    avg ? `Avg: ${avg.toFixed(1)}s` : null,
                    ema ? `EMA: ${ema.toFixed(1)}s` : null,
                    `Blended: ${blended.toFixed(1)}s (${pct.toFixed(0)}%)`,
                  ]
                    .filter(Boolean)
                    .join("&#10;");
                }
                return `
                <tr>
                  <td title="${miner.worker}">${displayWorker(
                  miner.worker
                )}</td>
                  <td>${miner.software || ""}</td>
                  <td class=\"col-num\" title=\"Assigned difficulty (raw value)\">${diffCell}</td>
                  <td class=\"col-num\" title=\"${hashrateTooltip}\">${formatHashrate(
                  miner
                )}</td>
                  <td class=\"col-num\" title=\"${shareIntvlTooltip}\">${shareIntvlDisplay}</td>
                  <td class=\"col-num\">${formatUptime(
                    miner.uptime_seconds || 0
                  )}</td>
                </tr>`;
              })
              .join("");
          }

          // Update pagination controls
          updateMinersPaginationControls();
        } catch (error) {
          console.error("Error fetching miners:", error);
        }
      }

      function updateMinersPaginationControls() {
        const totalPages =
          Math.ceil(
            minersPaginationState.miners.length / minersPaginationState.limit
          ) || 1;
        const pageInfo = document.getElementById("miners-page-info");
        if (pageInfo) {
          pageInfo.textContent = `Page ${minersPaginationState.page} of ${totalPages}`;
        }

        const prevBtn = document.getElementById("miners-prev-btn");
        const nextBtn = document.getElementById("miners-next-btn");
        if (prevBtn) prevBtn.disabled = minersPaginationState.page <= 1;
        if (nextBtn)
          nextBtn.disabled = minersPaginationState.page >= totalPages;
      }

      async function updateDisconnectedMiners() {
        try {
          const hours = parseInt(
            document.getElementById("disconnected-miners-hours")?.value || "24"
          );
          const response = await fetch(
            `/api/miners/disconnected?hours=${hours}&page=1&limit=50`
          );
          const data = await response.json();

          const tbody = document.getElementById("disconnected-miners-body");
          if (data.miners.length === 0) {
            tbody.innerHTML =
              '<tr><td colspan="5" class="no-data">No recently disconnected miners</td></tr>';
          } else {
            tbody.innerHTML = data.miners
              .map((miner) => {
                const lastSeen = new Date(miner.last_seen * 1000);
                const timeAgo = getTimeAgo(lastSeen);
                return `
                <tr>
                  <td title="${miner.worker_name}">${displayWorker(
                  miner.worker_name
                )}</td>
                  <td>${miner.miner_software || "Unknown"}</td>
                  <td>${timeAgo}</td>
                  <td>${formatDate(lastSeen)}</td>
                  <td>
                    <button class="action-btn" onclick="clearMinerRecord('${miner.worker_name.replace(
                      /'/g,
                      "\\'"
                    )}')">Clear</button>
                  </td>
                </tr>`;
              })
              .join("");
          }
        } catch (error) {
          console.error("Error fetching disconnected miners:", error);
        }
      }

      async function clearMinerRecord(workerName) {
        if (
          !confirm(
            `Are you sure you want to delete the record for "${workerName}"?`
          )
        ) {
          return;
        }

        try {
          const response = await fetch(
            `/api/miners/${encodeURIComponent(workerName)}/clear`,
            {
              method: "POST",
            }
          );

          if (response.ok) {
            await updateDisconnectedMiners();
            showNotification(`Cleared record for ${workerName}`);
          } else {
            showNotification(
              `Failed to clear record for ${workerName}`,
              "error"
            );
          }
        } catch (error) {
          console.error("Error clearing miner record:", error);
          showNotification("Error clearing miner record", "error");
        }
      }

      async function updateStats() {
        try {
          const response = await fetch("/api/stats");
          const data = await response.json();

          document.getElementById("kcn-blocks").textContent =
            data.blocks.KCN || 0;
          document.getElementById("lcn-blocks").textContent =
            data.blocks.LCN || 0;
          if (data.blocks_all_time) {
            const kEl = document.getElementById("kcn-blocks-alltime");
            const lEl = document.getElementById("lcn-blocks-alltime");
            if (kEl)
              kEl.textContent =
                "All time: " + (data.blocks_all_time.KCN || 0).toLocaleString();
            if (lEl)
              lEl.textContent =
                "All time: " + (data.blocks_all_time.LCN || 0).toLocaleString();
          }
          document.getElementById("acceptance-rate").textContent =
            data.acceptance_rate !== null
              ? data.acceptance_rate.toFixed(2)
              : "—";
          document.getElementById("total-shares").textContent =
            data.total_shares.toLocaleString();
          // Network heights & difficulty (KCN/LCN)
          try {
            const kHeight = data.current_height_kcn;
            const lHeight = data.current_height_lcn;
            const kDiff = data.current_kcn_difficulty;
            const lDiff = data.current_lcn_difficulty;

            // Update KCN network card
            const kHeightEl = document.getElementById("kcn-height");
            const kDiffEl = document.getElementById("kcn-difficulty");
            if (kHeightEl && kHeight != null) {
              kHeightEl.textContent = kHeight;
              kHeightEl.title = `KCN blockchain height: ${kHeight}`;
            }
            if (kDiffEl && kDiff != null) {
              kDiffEl.textContent = kDiff.toFixed(8);
              kDiffEl.title = `KCN network difficulty: ${kDiff}`;
            }

            // Update LCN network card
            const lHeightEl = document.getElementById("lcn-height");
            const lDiffEl = document.getElementById("lcn-difficulty");
            if (lHeightEl && lHeight != null) {
              lHeightEl.textContent = lHeight;
              lHeightEl.title = `LCN blockchain height: ${lHeight}`;
            }
            if (lDiffEl && lDiff != null) {
              lDiffEl.textContent = lDiff.toFixed(6);
              lDiffEl.title = `LCN network difficulty: ${lDiff}`;
            }
          } catch (e) {
            /* ignore */
          }
          if (data.shares_since_last_block != null) {
            document.getElementById("shares-since-block").textContent =
              data.shares_since_last_block.toLocaleString();
            if (data.last_block_time) {
              const ageSec = Math.max(
                0,
                Math.floor(Date.now() / 1000 - data.last_block_time)
              );
              let ageStr;
              if (ageSec < 60) ageStr = ageSec + "s";
              else if (ageSec < 3600) ageStr = Math.floor(ageSec / 60) + "m";
              else if (ageSec < 86400) ageStr = Math.floor(ageSec / 3600) + "h";
              else ageStr = Math.floor(ageSec / 86400) + "d";
              const ageEl = document.getElementById("shares-since-block-age");
              ageEl.textContent = ageStr;
              ageEl.title = new Date(data.last_block_time * 1000).toISOString();
            } else {
              document.getElementById("shares-since-block-age").textContent =
                "—";
            }
          } else {
            document.getElementById("shares-since-block").textContent = "—";
            document.getElementById("shares-since-block-age").textContent = "—";
          }

          // Update TTF estimates
          const ttfKcnEl = document.getElementById("ttf-kcn");
          const ttfLcnEl = document.getElementById("ttf-lcn");
          if (ttfKcnEl) {
            ttfKcnEl.textContent = formatTTF(data.ttf_kcn_seconds);
            ttfKcnEl.title = data.ttf_kcn_seconds
              ? `${Math.round(data.ttf_kcn_seconds).toLocaleString()} seconds`
              : "No hashrate data";
          }
          if (ttfLcnEl) {
            ttfLcnEl.textContent = formatTTF(data.ttf_lcn_seconds);
            ttfLcnEl.title = data.ttf_lcn_seconds
              ? `${Math.round(data.ttf_lcn_seconds).toLocaleString()} seconds`
              : "No hashrate data";
          }
        } catch (error) {
          console.error("Error fetching stats:", error);
        }
      }

      // Pagination state for blocks with localStorage persistence
      const blocksPaginationState = {
        kcn: { all: [], page: 1, perPage: 10, total: 0 },
        lcn: { all: [], page: 1, perPage: 10, total: 0 },
      };

      // Load saved pagination state from localStorage
      function loadPaginationState() {
        try {
          const saved = localStorage.getItem("blocksPaginationPages");
          if (saved) {
            const pages = JSON.parse(saved);
            blocksPaginationState.kcn.page = pages.kcn || 1;
            blocksPaginationState.lcn.page = pages.lcn || 1;
          }
        } catch (e) {
          console.debug("Could not load pagination state:", e);
        }
      }

      // Save pagination state to localStorage
      function savePaginationState() {
        try {
          localStorage.setItem(
            "blocksPaginationPages",
            JSON.stringify({
              kcn: blocksPaginationState.kcn.page,
              lcn: blocksPaginationState.lcn.page,
            })
          );
        } catch (e) {
          console.debug("Could not save pagination state:", e);
        }
      }

      async function updateBlocks() {
        try {
          // Calculate offset based on current page
          const kcnPage = blocksPaginationState.kcn.page;
          const lcnPage = blocksPaginationState.lcn.page;
          const perPage = 10;

          // Fetch KCN blocks for current page
          const kcnOffset = (kcnPage - 1) * perPage;
          const kcnResponse = await fetch(
            `/api/blocks?limit=${perPage}&offset=${kcnOffset}`
          );
          const kcnData = await kcnResponse.json();

          const kcnBlocks = kcnData.blocks.filter((b) => b.chain === "KCN");
          const allKcnTotal = kcnData.blocks.filter(
            (b) => b.chain === "KCN"
          ).length;

          // Fetch LCN blocks for current page
          const lcnOffset = (lcnPage - 1) * perPage;
          const lcnResponse = await fetch(
            `/api/blocks?limit=${perPage}&offset=${lcnOffset}`
          );
          const lcnData = await lcnResponse.json();

          const lcnBlocks = lcnData.blocks.filter((b) => b.chain === "LCN");

          // Store blocks and total count for pagination
          blocksPaginationState.kcn.all = kcnBlocks;
          blocksPaginationState.kcn.total = kcnData.total;
          blocksPaginationState.lcn.all = lcnBlocks;
          blocksPaginationState.lcn.total = kcnData.total;

          // Render current pages
          renderBlocksPage("kcn");
          renderBlocksPage("lcn");
        } catch (error) {
          console.error("Error fetching blocks:", error);
          document.getElementById("kcn-blocks-body").innerHTML =
            '<tr><td colspan="5" class="no-data">Error</td></tr>';
          document.getElementById("lcn-blocks-body").innerHTML =
            '<tr><td colspan="5" class="no-data">Error</td></tr>';
        }
      }

      function renderBlocksPage(chain) {
        const state = blocksPaginationState[chain];
        const tbody = document.getElementById(`${chain}-blocks-body`);
        const paginationDiv = document.getElementById(`${chain}-pagination`);
        const pageInfo = document.getElementById(`${chain}-page-info`);
        const blocks = state.all;
        const page = state.page;
        const totalCount = state.total;

        // Calculate total pages from server-reported total
        const perPage = 10;
        const totalPages = Math.ceil(totalCount / perPage);

        function renderBlockRow(block) {
          const absTime = new Date(block.timestamp * 1000).toISOString();
          const explorerBase =
            block.chain === "KCN"
              ? "https://kcnxp.com/block/"
              : "https://lcnxp.com/block/";
          return `
            <tr>
              <td class="col-num">${block.height}</td>
              <td class="hash-short">
                <div class="copy-wrap" title="${block.block_hash}">
                  <a class="hash-link" href="${
                    explorerBase + block.block_hash
                  }" target="_blank" rel="noopener" aria-label="View block on explorer">${shortenHash(
            block.block_hash
          )}</a>
                  <button class="copy-btn" onclick="copyToClipboard('${
                    block.block_hash
                  }', this)" aria-label="Copy block hash">Copy</button>
                </div>
              </td>
              <td title="${block.worker}">${displayWorker(block.worker)}</td>
              <td><span class="badge badge-${
                block.accepted ? "accepted" : "rejected"
              }">${block.accepted ? "Accepted" : "Rejected"}</span></td>
              <td class="col-num" title="${absTime}">${formatTime(
            block.timestamp
          )}</td>
            </tr>`;
        }

        // Render table
        if (blocks.length === 0) {
          tbody.innerHTML = `<tr><td colspan="5" class="no-data">No ${chain.toUpperCase()} blocks yet</td></tr>`;
          paginationDiv.style.display = "none";
        } else {
          tbody.innerHTML = blocks.map(renderBlockRow).join("");

          // Show pagination if multiple pages
          if (totalPages > 1) {
            paginationDiv.style.display = "flex";
            pageInfo.textContent = `Page ${page} of ${totalPages}`;

            // Update button states
            const prevBtn = paginationDiv.querySelector(
              '[onclick*="prevBlocksPage"]'
            );
            const nextBtn = paginationDiv.querySelector(
              '[onclick*="nextBlocksPage"]'
            );
            if (prevBtn) prevBtn.disabled = page === 1;
            if (nextBtn) nextBtn.disabled = page === totalPages;
          } else {
            paginationDiv.style.display = "none";
          }
        }
      }

      function prevBlocksPage(chain) {
        if (blocksPaginationState[chain].page > 1) {
          blocksPaginationState[chain].page--;
          savePaginationState();
          updateBlocksForChain(chain);
        }
      }

      function nextBlocksPage(chain) {
        const state = blocksPaginationState[chain];
        const perPage = 10;
        const totalPages = Math.ceil(state.total / perPage);
        if (state.page < totalPages) {
          state.page++;
          savePaginationState();
          updateBlocksForChain(chain);
        }
      }

      // Update blocks for a specific chain only
      async function updateBlocksForChain(chain) {
        try {
          const state = blocksPaginationState[chain];
          const perPage = 10;
          const offset = (state.page - 1) * perPage;

          const response = await fetch(
            `/api/blocks?limit=${perPage}&offset=${offset}`
          );
          const data = await response.json();

          const chainBlocks = data.blocks.filter(
            (b) => b.chain === chain.toUpperCase()
          );
          state.all = chainBlocks;
          state.total = data.total;

          renderBlocksPage(chain);
        } catch (error) {
          console.error(`Error fetching ${chain} blocks:`, error);
        }
      }

      async function updateBestShares() {
        try {
          const response = await fetch("/api/best-shares");
          const data = await response.json();

          const tbody = document.getElementById("best-shares-body");

          function renderBestShareRow(share, index) {
            const absTime = new Date(share.timestamp * 1000).toLocaleString();

            // Extract worker name (part after last dot, or first 8 chars if no dot)
            let workerName = share.worker;
            if (share.worker.includes(".")) {
              workerName = share.worker.split(".").pop();
            } else {
              workerName = share.worker.substring(0, 8);
            }

            // Rank styling for top 3
            let rankDisplay = (index + 1).toString();
            let rankClass = "";
            if (index === 0) {
              rankDisplay = "🥇";
              rankClass = "rank-gold";
            } else if (index === 1) {
              rankDisplay = "🥈";
              rankClass = "rank-silver";
            } else if (index === 2) {
              rankDisplay = "🥉";
              rankClass = "rank-bronze";
            }

            // Format ratios with appropriate styling
            const kcnRatio = formatRatio(share.kcn_ratio);
            const lcnRatio = formatRatio(share.lcn_ratio);

            return `
              <tr>
                <td class="col-num ${rankClass}">${rankDisplay}</td>
                <td title="${share.share_difficulty}">${formatDifficulty(
              share.share_difficulty
            )}</td>
                <td title="KCN target ratio" class="ratio-kcn">${kcnRatio}</td>
                <td title="LCN target ratio" class="ratio-lcn">${lcnRatio}</td>
                <td class="worker-name" title="${share.worker}">
                  <span class="worker-text">${workerName}</span>
                </td>
                <td class="col-num" title="${absTime}">${formatTime(
              share.timestamp
            )}</td>
              </tr>`;
          }

          tbody.innerHTML = data.shares?.length
            ? data.shares.map(renderBestShareRow).join("")
            : '<tr><td colspan="7" class="no-data">No shares yet</td></tr>';
        } catch (error) {
          console.error("Error fetching best shares:", error);
          document.getElementById("best-shares-body").innerHTML =
            '<tr><td colspan="7" class="no-data">Error loading best shares</td></tr>';
        }
      }

      async function updatePayouts() {
        try {
          const response = await fetch("/api/payouts");
          const data = await response.json();

          const tbody = document.getElementById("payouts-body");
          const rows = [];

          // KCN payout info
          if (data.kcn_address) {
            const source =
              data.kcn_source === "first_miner" ? "First Miner" : "Config";
            rows.push(`
                        <tr>
                            <td><span class="badge badge-kcn"><img src="/static/kylacoin-logo.png" alt="" class="chain-logo" onerror="this.style.display='none'">KCN</span></td>
                            <td class="hash-short"><div class="copy-wrap" title="${
                              data.kcn_address
                            }"><a class="hash-link" href="https://kcnxp.com/address/${
              data.kcn_address
            }" target="_blank" rel="noopener" aria-label="View KCN address on explorer">${shortenHash(
              data.kcn_address
            )}</a><button class="copy-btn" onclick="copyToClipboard('${
              data.kcn_address
            }', this)" aria-label="Copy KCN address">Copy</button></div></td>
                            <td>${source}</td>
                        </tr>
                    `);
          } else {
            rows.push(`
                        <tr>
                            <td><span class="badge badge-kcn"><img src="/static/kylacoin-logo.png" alt="" class="chain-logo" onerror="this.style.display='none'">KCN</span></td>
                            <td><em>Will be set by first miner</em></td>
                            <td>Auto</td>
                        </tr>
                    `);
          }

          // LCN payout info
          if (data.lcn_address) {
            rows.push(`
                        <tr>
                            <td><span class="badge badge-lcn"><img src="/static/lyncoin-logo.png" alt="" class="chain-logo" onerror="this.style.display='none'">LCN</span></td>
              <td class="hash-short"><div class="copy-wrap" title="${
                data.lcn_address
              }"><a class="hash-link" href="https://lcnxp.com/address/${
              data.lcn_address
            }" target="_blank" rel="noopener" aria-label="View LCN address on explorer">${shortenHash(
              data.lcn_address
            )}</a><button class="copy-btn" onclick="copyToClipboard('${
              data.lcn_address
            }', this)" aria-label="Copy LCN address">Copy</button></div></td>
                            <td>Config (.env)</td>
                        </tr>
                    `);
          } else {
            rows.push(`
                        <tr>
                            <td><span class="badge badge-lcn"><img src="/static/lyncoin-logo.png" alt="" class="chain-logo" onerror="this.style.display='none'">LCN</span></td>
                            <td><em>Not configured (KCN only)</em></td>
                            <td>Disabled</td>
                        </tr>
                    `);
          }

          tbody.innerHTML = rows.join("");
        } catch (error) {
          console.error("Error fetching payouts:", error);
          document.getElementById("payouts-body").innerHTML =
            '<tr><td colspan="3" class="no-data">Error loading payout info</td></tr>';
        }
      }

      async function checkLcnHashFixStatus() {
        try {
          const response = await fetch("/api/lcn_hash_fix_status");
          const status = await response.json();

          const fixGroup = document.getElementById("fix-lcn-group");
          const fixBtn = document.getElementById("fix-lcn-hashes");

          if (status.show_button && status.bad_hash_count > 0) {
            // Show the fix controls
            fixGroup.style.display = "flex";
            // Update button text with count
            fixBtn.textContent = `Fix LCN Hashes (${status.bad_hash_count})`;
            fixBtn.title = `Correct ${status.bad_hash_count} historical LCN block hashes using node RPC`;
          } else {
            // Hide the fix controls (already fixed or not needed)
            fixGroup.style.display = "none";
          }
        } catch (error) {
          console.error("Error checking LCN hash fix status:", error);
          // On error, hide the controls
          const fixGroup = document.getElementById("fix-lcn-group");
          if (fixGroup) fixGroup.style.display = "none";
        }
      }

      async function updateSystemConfig() {
        try {
          const response = await fetch("/api/system/config");
          const config = await response.json();

          // Hide loading indicator
          const loadingEl = document.getElementById("status-loading");
          if (loadingEl) loadingEl.style.display = "none";

          // VarDiff status
          const vardiffEl = document.getElementById("status-vardiff");
          if (config.vardiff?.enabled) {
            vardiffEl.style.display = "flex";
            const detail = vardiffEl.querySelector(".status-detail");
            detail.textContent = `(target: ${config.vardiff.target_interval}s)`;
            detail.title = `Min: ${config.vardiff.min_difficulty}, Max: ${config.vardiff.max_difficulty}`;
          }

          // ZMQ status
          const zmqEl = document.getElementById("status-zmq");
          if (config.zmq?.enabled) {
            zmqEl.style.display = "flex";
          }

          // Notifications status
          const notifEl = document.getElementById("status-notifications");
          const notifServices = [];
          if (config.notifications?.discord) notifServices.push("Discord");
          if (config.notifications?.telegram) notifServices.push("Telegram");
          if (notifServices.length > 0) {
            notifEl.style.display = "flex";
            const detail = notifEl.querySelector(".status-detail");
            detail.textContent = `(${notifServices.join(", ")})`;
          }

          // Database status
          const dbEl = document.getElementById("status-database");
          if (config.database?.enabled) {
            dbEl.style.display = "flex";
          }

          // Stratum port (always show)
          const stratumEl = document.getElementById("status-stratum");
          if (config.stratum?.port) {
            const detail = stratumEl.querySelector(".status-detail");
            detail.textContent = config.stratum.port;
            stratumEl.title = `Stratum server listening on port ${config.stratum.port}`;
          }
        } catch (error) {
          console.error("Error fetching system config:", error);
          const loadingEl = document.getElementById("status-loading");
          if (loadingEl) {
            loadingEl.textContent = "Error loading configuration";
            loadingEl.style.color = "#ff6b6b";
          }
        }
      }

      function showNotification(message, type = "success") {
        // Create a notification element
        const notif = document.createElement("div");
        notif.textContent = message;
        notif.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 12px 16px;
          background: ${type === "error" ? "#e74c3c" : "#27ae60"};
          color: white;
          border-radius: 4px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
          z-index: 10000;
          font-weight: 500;
          animation: slideIn 0.3s ease-out;
        `;
        document.body.appendChild(notif);

        // Auto-remove after 3 seconds
        setTimeout(() => {
          notif.style.animation = "slideOut 0.3s ease-in";
          setTimeout(() => notif.remove(), 300);
        }, 3000);
      }

      function updateAll() {
        updateMiners();
        updateStats();
        updateBlocks();
        updateBestShares();
        updatePayouts();
        updateDaemonStatus(); // Add daemon status updates
        updateDisconnectedMiners(); // Update disconnected miners list
        document.getElementById("last-update").textContent =
          new Date().toLocaleTimeString();
      }

      // Initial load
      loadPaginationState(); // Load saved pagination state before updating
      updateAll();
      updateSystemConfig(); // Load system config once on startup
      checkLcnHashFixStatus(); // Check if LCN hash fix is needed

      // Auto-refresh every 5 seconds
      setInterval(updateAll, 5000);

      // Update blocks layout based on compact mode
      function updateBlocksLayout() {
        const container = document.getElementById("blocks-container");
        if (!container) return;

        if (workerCompactMode) {
          // Compact mode: side by side
          container.style.gridTemplateColumns =
            "repeat(auto-fit, minmax(480px, 1fr))";
        } else {
          // Full mode: stack vertically
          container.style.gridTemplateColumns = "1fr";
        }
      }

      // Worker name compact/full toggle logic
      (function initWorkerToggle() {
        const stored = localStorage.getItem("workerCompactMode");
        if (stored === "full") {
          workerCompactMode = false;
        }
        const cb = document.getElementById("worker-mode-toggle");
        if (cb) {
          cb.checked = workerCompactMode;
          cb.addEventListener("change", () => {
            workerCompactMode = cb.checked;
            localStorage.setItem(
              "workerCompactMode",
              workerCompactMode ? "compact" : "full"
            );
            // Update blocks layout when toggling
            updateBlocksLayout();
            // Re-render without forcing network if desired; simplest: call update
            updateMiners();
            updateBlocks();
          });
        }
        // Apply initial layout
        updateBlocksLayout();
      })();

      // Flush hashrate button
      (function initFlushButton() {
        const btn = document.getElementById("flush-hashrate");
        if (!btn) return;
        btn.addEventListener("click", async () => {
          btn.disabled = true;
          try {
            const res = await fetch("/api/flush_hashrate", { method: "POST" });
            const js = await res.json();
            btn.textContent = "Flushed (" + (js.cleared_workers || 0) + ")";
            setTimeout(() => {
              btn.textContent = "Flush Hashrate Window";
              btn.disabled = false;
              updateMiners();
            }, 2500);
          } catch (e) {
            console.error("Flush failed", e);
            btn.textContent = "Error";
            setTimeout(() => {
              btn.textContent = "Flush Hashrate Window";
              btn.disabled = false;
            }, 2500);
          }
        });
      })();

      // Clear best shares button
      (function initClearBestSharesButton() {
        const btn = document.getElementById("clear-best-shares");
        if (!btn) return;
        btn.addEventListener("click", async () => {
          if (
            !confirm(
              "Clear all best shares and start over? This cannot be undone."
            )
          ) {
            return;
          }
          btn.disabled = true;
          try {
            const res = await fetch("/api/clear_best_shares", {
              method: "POST",
            });
            const js = await res.json();
            btn.textContent = "Cleared";
            setTimeout(() => {
              btn.textContent = "Clear";
              btn.disabled = false;
              updateBestShares();
            }, 1500);
          } catch (e) {
            console.error("Clear failed", e);
            btn.textContent = "Error";
            setTimeout(() => {
              btn.textContent = "Clear";
              btn.disabled = false;
            }, 1500);
          }
        });
      })();

      // Fix LCN hashes button with dry-run + limit controls
      (function initFixHashesButton() {
        const btn = document.getElementById("fix-lcn-hashes");
        const dryCk = document.getElementById("fix-lcn-dryrun");
        const limitInput = document.getElementById("fix-lcn-limit");
        const statusEl = document.getElementById("fix-lcn-status");
        if (!btn) return;
        btn.addEventListener("click", async () => {
          const dryRun = dryCk ? dryCk.checked : true;
          const limitVal =
            limitInput && limitInput.value.trim() !== ""
              ? limitInput.value.trim()
              : null;
          if (
            !confirm(
              `Run LCN hash correction now?${dryRun ? " (dry‑run)" : ""}`
            )
          )
            return;
          btn.disabled = true;
          const original = btn.textContent;
          btn.textContent = "Running...";
          if (statusEl) statusEl.textContent = "";
          try {
            let url = "/api/fix_lcn_aux_hashes";
            const params = [];
            if (dryRun) params.push("dry_run=1");
            if (limitVal) params.push("limit=" + encodeURIComponent(limitVal));
            if (params.length) url += "?" + params.join("&");
            const res = await fetch(url, { method: "POST" });
            const js = await res.json();
            if (js.error) {
              btn.textContent = "Error";
              if (statusEl) statusEl.textContent = js.error;
              console.error(js.error);
            } else {
              btn.textContent = js.dry_run
                ? `Dry‑run ${js.updated}/${js.checked}`
                : `Fixed ${js.updated}/${js.checked}`;
              if (statusEl) {
                const pending = js.checked - js.updated;
                statusEl.textContent = `Checked ${js.checked} · Updated ${
                  js.updated
                }${js.dry_run ? " (dry‑run)" : ""}${
                  pending && js.updated ? ` · Remaining ~${pending}` : ""
                }`;
              }
              // If not dry-run and completed, recheck status to hide button
              if (!js.dry_run && js.checked > 0) {
                setTimeout(() => checkLcnHashFixStatus(), 1000);
              }
            }
          } catch (e) {
            btn.textContent = "Error";
            if (statusEl) statusEl.textContent = "Request failed";
            console.error(e);
          }
          setTimeout(() => {
            btn.textContent = original;
            btn.disabled = false;
            if (statusEl) statusEl.textContent = "";
          }, 6000);
        });
      })();

      // Remember hashrate mode toggle
      (function initHashrateMode() {
        const cb = document.getElementById("mode-toggle-hashrate");
        if (!cb) return;
        const stored = localStorage.getItem("hashrateDisplayMode");
        if (stored === "instant") cb.checked = true;
        cb.addEventListener("change", () => {
          localStorage.setItem(
            "hashrateDisplayMode",
            cb.checked ? "instant" : "ema"
          );
          // force immediate refresh of miners aggregate view only
          updateMiners();
        });
      })();

      // Theme toggle (light/dark)
      (function initThemeToggle() {
        const btn = document.getElementById("theme-toggle");
        if (!btn) return;
        const root = document.documentElement;
        const stored = localStorage.getItem("dashboardTheme");
        function setLabel() {
          const isLight = root.getAttribute("data-theme") === "light";
          const iconSpan = btn.querySelector(".icon");
          if (isLight) {
            btn
              .querySelector(".label")
              ?.replaceChildren(document.createTextNode("Dark Mode"));
            if (iconSpan) iconSpan.textContent = "☀️";
          } else {
            btn
              .querySelector(".label")
              ?.replaceChildren(document.createTextNode("Light Mode"));
            if (iconSpan) iconSpan.textContent = "🌙";
          }
        }
        if (stored === "light") {
          root.setAttribute("data-theme", "light");
        } else {
          root.removeAttribute("data-theme");
        }
        setLabel();
        btn.addEventListener("click", () => {
          const isLight = root.getAttribute("data-theme") === "light";
          // Add fade class for cross-fade effect
          document.body.classList.remove("theme-fade");
          void document.body.offsetWidth; // force reflow
          document.body.classList.add("theme-fade");
          if (isLight) {
            root.removeAttribute("data-theme");
            localStorage.setItem("dashboardTheme", "dark");
          } else {
            root.setAttribute("data-theme", "light");
            localStorage.setItem("dashboardTheme", "light");
          }
          setLabel();
        });
      })();

      // Chart.js configurations and functions
      let difficultyChart = null;
      let hashrateChart = null;
      let currentDifficultyHours = 24;
      let currentHashrateHours = 24;

      function getChartColors() {
        const root = document.documentElement;
        const isDark =
          !root.getAttribute("data-theme") ||
          root.getAttribute("data-theme") === "dark";
        return {
          kcnColor: isDark ? "#ff1493" : "#d91e63",
          lcnColor: isDark ? "#ff8c00" : "#f57c00",
          gridColor: isDark ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)",
          textColor: isDark ? "#e0e0e0" : "#333333",
          backgroundColor: isDark ? "#1a1a1a" : "#ffffff",
        };
      }

      async function updateDifficultyChart(hours) {
        currentDifficultyHours = hours;
        const colors = getChartColors();

        try {
          // Fetch KCN difficulty history
          const kcnRes = await fetch(
            `/api/difficulty-history/KCN?hours=${hours}`
          );
          const kcnData = await kcnRes.json();

          // Fetch LCN difficulty history
          const lcnRes = await fetch(
            `/api/difficulty-history/LCN?hours=${hours}`
          );
          const lcnData = await lcnRes.json();

          // Prepare chart data
          const kcnPoints = kcnData.data || [];
          const lcnPoints = lcnData.data || [];

          // Get all unique timestamps and sort
          const timestamps = new Set();
          kcnPoints.forEach((p) => timestamps.add(p.timestamp));
          lcnPoints.forEach((p) => timestamps.add(p.timestamp));
          const sortedTimestamps = Array.from(timestamps).sort((a, b) => a - b);

          // Format timestamps for display
          const labels = sortedTimestamps.map((ts) => {
            const date = new Date(ts * 1000);
            const hour = String(date.getHours()).padStart(2, "0");
            const min = String(date.getMinutes()).padStart(2, "0");
            return `${hour}:${min}`;
          });

          // Create data point lookups
          const kcnLookup = {};
          kcnPoints.forEach((p) => (kcnLookup[p.timestamp] = p.difficulty));
          const lcnLookup = {};
          lcnPoints.forEach((p) => (lcnLookup[p.timestamp] = p.difficulty));

          // Build datasets with null for missing values
          const kcnDataset = sortedTimestamps.map(
            (ts) => kcnLookup[ts] || null
          );
          const lcnDataset = sortedTimestamps.map(
            (ts) => lcnLookup[ts] || null
          );

          const ctx = document
            .getElementById("difficulty-chart")
            .getContext("2d");

          if (difficultyChart) {
            difficultyChart.destroy();
          }

          difficultyChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: labels,
              datasets: [
                {
                  label: "KCN Difficulty",
                  data: kcnDataset,
                  borderColor: colors.kcnColor,
                  backgroundColor: colors.kcnColor + "15",
                  borderWidth: 2,
                  fill: true,
                  tension: 0.4,
                  pointRadius: 3,
                  pointBackgroundColor: colors.kcnColor,
                  pointBorderColor: colors.backgroundColor,
                  pointBorderWidth: 2,
                },
                {
                  label: "LCN Difficulty",
                  data: lcnDataset,
                  borderColor: colors.lcnColor,
                  backgroundColor: colors.lcnColor + "15",
                  borderWidth: 2,
                  fill: true,
                  tension: 0.4,
                  pointRadius: 3,
                  pointBackgroundColor: colors.lcnColor,
                  pointBorderColor: colors.backgroundColor,
                  pointBorderWidth: 2,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: true,
                  labels: {
                    color: colors.textColor,
                    usePointStyle: true,
                    padding: 20,
                    font: { size: 12 },
                  },
                },
                filler: {
                  propagate: true,
                },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      let label = context.dataset.label || "";
                      if (label) {
                        label += ": ";
                      }
                      if (context.parsed.y !== null) {
                        label += context.parsed.y.toFixed(6);
                      }
                      return label;
                    },
                  },
                },
              },
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: colors.gridColor,
                  },
                  ticks: {
                    color: colors.textColor,
                    font: { size: 11 },
                  },
                },
                x: {
                  grid: {
                    color: colors.gridColor,
                  },
                  ticks: {
                    color: colors.textColor,
                    font: { size: 11 },
                    maxTicksLimit: 12,
                  },
                },
              },
            },
          });
        } catch (error) {
          console.error("Error updating difficulty chart:", error);
        }
      }

      async function updateHashrateChart(hours) {
        currentHashrateHours = hours;
        const colors = getChartColors();

        try {
          const res = await fetch(`/api/hashrate-history?hours=${hours}`);
          const data = await res.json();
          const points = data.data || [];

          // Sort by timestamp
          points.sort((a, b) => a.timestamp - b.timestamp);

          // Format labels
          const labels = points.map((p) => {
            const date = new Date(p.timestamp * 1000);
            const hour = String(date.getHours()).padStart(2, "0");
            const min = String(date.getMinutes()).padStart(2, "0");
            return `${hour}:${min}`;
          });

          // Convert hashrate to KH/s for display
          const hashrates = points.map((p) => p.hashrate_hs / 1e3);

          // Calculate average and peak
          const avg =
            hashrates.length > 0
              ? hashrates.reduce((a, b) => a + b, 0) / hashrates.length
              : 0;
          const peak = hashrates.length > 0 ? Math.max(...hashrates) : 0;

          const ctx = document
            .getElementById("hashrate-chart")
            .getContext("2d");

          if (hashrateChart) {
            hashrateChart.destroy();
          }

          hashrateChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: labels,
              datasets: [
                {
                  label: "Hashrate (KH/s)",
                  data: hashrates,
                  borderColor: colors.kcnColor,
                  backgroundColor: colors.kcnColor + "25",
                  borderWidth: 2.5,
                  fill: true,
                  tension: 0.4,
                  pointRadius: 2,
                  pointBackgroundColor: colors.kcnColor,
                  pointBorderColor: colors.backgroundColor,
                  pointBorderWidth: 1,
                },
                {
                  label: `Average (${avg.toFixed(2)} KH/s)`,
                  data: new Array(labels.length).fill(avg),
                  borderColor: colors.textColor,
                  borderWidth: 1,
                  borderDash: [5, 5],
                  fill: false,
                  pointRadius: 0,
                  pointHoverRadius: 0,
                  tension: 0,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: true,
                  labels: {
                    color: colors.textColor,
                    usePointStyle: true,
                    padding: 20,
                    font: { size: 12 },
                  },
                },
                filler: {
                  propagate: true,
                },
              },
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: colors.gridColor,
                  },
                  ticks: {
                    color: colors.textColor,
                    font: { size: 11 },
                    callback: function (value) {
                      return value.toFixed(1) + " KH/s";
                    },
                  },
                },
                x: {
                  grid: {
                    color: colors.gridColor,
                  },
                  ticks: {
                    color: colors.textColor,
                    font: { size: 11 },
                    maxTicksLimit: 12,
                  },
                },
              },
            },
          });
        } catch (error) {
          console.error("Error updating hashrate chart:", error);
        }
      }

      // Initial chart loading
      (function initCharts() {
        updateDifficultyChart(24);
        updateHashrateChart(24);

        // Refresh charts every 5 minutes
        setInterval(() => {
          updateDifficultyChart(currentDifficultyHours);
          updateHashrateChart(currentHashrateHours);
        }, 5 * 60 * 1000);
      })();
    </script>
  </body>
</html>
